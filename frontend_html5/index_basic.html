<!DOCTYPE html>
<!-- Tutorial series by David Rousset: http://blogs.msdn.com/davrous -->
<!-- Based on this EaselJS sample: http://easeljs.com/examples/bitmapAnimation.html -->
<html>
<head>
<title>EaselJS Sprites Tutorial</title>

<!-- Import EaselJS Framework -->
<script src="http://code.createjs.com/easeljs-0.6.0.min.js"></script>
<script src="http://code.jquery.com/jquery-latest.min.js"
        type="text/javascript"></script>

<script>

    var KEYCODE_ENTER = 13;     //usefull keycode
    var KEYCODE_SPACE = 32;     //usefull keycode
    var KEYCODE_UP = 38;        //usefull keycode
    var KEYCODE_LEFT = 37;      //usefull keycode
    var KEYCODE_RIGHT = 39;     //usefull keycode
    var KEYCODE_W = 87;         //usefull keycode
    var KEYCODE_A = 65;         //usefull keycode
    var KEYCODE_S = 83;
    var KEYCODE_D = 68;         //usefull keycode
    document.onkeydown = handleKeyDown;

    var canvas;
    var stage;
    var screen_width;
    var screen_height;
    var bmpAnimation;
    var bmpAnimationIdle;

    var numberOfImagesLoaded = 0;

    var imgMonsterARun = new Image();
    var imgMonsterAIdle = new Image();

    function init() {
        //find canvas and load images, wait for last image to load
        canvas = document.getElementById("testCanvas");

        imgMonsterARun.onload = handleImageLoad;
        imgMonsterARun.onerror = handleImageError;
        imgMonsterARun.src = "assets/walk.png";

        imgMonsterAIdle.onload = handleImageLoad;
        imgMonsterAIdle.onerror = handleImageError;
        imgMonsterAIdle.src = "assets/shoot.png";
    }

    function handleImageLoad(e) {
        numberOfImagesLoaded++;

        // We're not starting the game until all images are loaded
        // Otherwise, you may start to draw without the resource and raise
        // this DOM Exception: INVALID_STATE_ERR (11) on the drawImage method
        if (numberOfImagesLoaded == 2) {
            numberOfImagesLoaded = 0;
            startGame();
        }
    }

    function reset() {
        stage.removeAllChildren();
        createjs.Ticker.removeAllListeners();
        stage.update();
    }

    function startGame() {
        // create a new stage and point it at our canvas:
        stage = new createjs.Stage(canvas);

        // grab canvas width and height for later calculations:
        screen_width = canvas.width;
        screen_height = canvas.height;

        // create spritesheet and assign the associated data.
        var spriteSheet = new createjs.SpriteSheet({
            //image to use
            images: [imgMonsterARun],
            //width, height & registration point of each sprite
            frames: { width: 32, height: 23 }, 
            // To slow down the animation loop of the sprite, we set the frequency to 4 to slow down by a 4x factor
            animations: {
                walk: [0, 2, "walk", 8]
            }
        });

        // to save file size, the loaded sprite sheet only includes left facing animations
        // we could flip the display objects with scaleX=-1, but this is expensive in most browsers
        // instead, we generate a new sprite sheet which includes the flipped animations
        createjs.SpriteSheetUtils.addFlippedFrames(spriteSheet, true, false, false);

        // Idle sequence of the monster
        var spriteSheetIdle = new createjs.SpriteSheet({
            images: [imgMonsterAIdle],
            frames: { width: 32, height: 23 }, 
            animations: {
                idle: [0, 3, "idle", 4]
            }
        });

        bmpAnimationIdle = new createjs.BitmapAnimation(spriteSheetIdle);

        bmpAnimationIdle.name = "monsteridle1";
        bmpAnimationIdle.x = 16;
        bmpAnimationIdle.y = 32;

        // create a BitmapSequence instance to display and play back the sprite sheet:
        bmpAnimation = new createjs.BitmapAnimation(spriteSheet);

        // set the registration point (the point it will be positioned and rotated around)
        // to the center of the frame dimensions:
        bmpAnimation.regX = bmpAnimation.spriteSheet.frameWidth / 2 | 0;
        bmpAnimation.regY = bmpAnimation.spriteSheet.frameHeight / 2 | 0;

        // start playing the first sequence:
        // walk_h has been generated by addFlippedFrames and
        // contained the right facing animations
        bmpAnimation.gotoAndPlay("walk_h");     //walking from left to right

        // set up a shadow. Note that shadows are ridiculously expensive. You could display hundreds
        // of animated rats if you disabled the shadow.
        bmpAnimation.shadow = new createjs.Shadow("#454", 0, 5, 4);

        bmpAnimation.name = "monster1";
        bmpAnimation.direction = 90;
        bmpAnimation.vX = 4;
        bmpAnimation.vY = 4;
        bmpAnimation.x = 200;
        bmpAnimation.y = 200;

        // have each monster start at a specific frame
        bmpAnimation.currentFrame = 0;
        stage.addChild(bmpAnimation);

        // we want to do some work before we update the canvas,
        // otherwise we could use Ticker.addListener(stage);
        createjs.Ticker.addListener(window);
        createjs.Ticker.useRAF = true;
        // Best Framerate targeted (60 FPS)
        createjs.Ticker.setFPS(60);
    }

    //called if there is an error loading the image (usually due to a 404)
    function handleImageError(e) {
        console.log("Error Loading Image : " + e.target.src);
    }

    function tick() {
        // // Hit testing the screen width, otherwise our sprite would disappear
        // if (bmpAnimation.x >= screen_width - 32) {
        //     // We've reached the right side of our screen
        //     // We need to walk left now to go back to our initial position
        //     bmpAnimation.direction = -90;
        //     bmpAnimation.gotoAndPlay("walk")
        // }

        // if (bmpAnimation.x < 0) {
        //     // We've reached the left side of our screen
        //     // We need to walk right now
        //     bmpAnimation.direction = 90;
        //     bmpAnimation.gotoAndStop("walk");
        //     stage.removeChild(bmpAnimation);
        //     bmpAnimationIdle.gotoAndPlay("idle");
        //     stage.addChild(bmpAnimationIdle);
        // }

        // // Moving the sprite based on the direction & the speed
        // if (bmpAnimation.direction == 90) {
        //     bmpAnimation.x += bmpAnimation.vX;
        //     bmpAnimation.y += bmpAnimation.vY;
        // }
        // else {
        //     bmpAnimation.x -= bmpAnimation.vX;
        //     bmpAnimation.y -= bmpAnimation.vY;
        // }

        // update the stage:
        stage.update();
        console.log('tick!');
    }
    //control
        //allow for WASD and arrow control scheme
    function handleKeyDown(e) {
        //cross browser issues exist
        if(!e){ var e = window.event; }
        switch(e.keyCode) {
            case KEYCODE_S: bmpAnimation.y += bmpAnimation.vY; return false;
            case KEYCODE_A: bmpAnimation.x -= bmpAnimation.vX; return false;
            case KEYCODE_D: bmpAnimation.x += bmpAnimation.vX; return false;
            case KEYCODE_W: bmpAnimation.y -= bmpAnimation.vY; return false;
            // FIXME: сделать выстрелы на управление
            case KEYCODE_LEFT: bmpAnimation.rotation -= 5; return false;
            case KEYCODE_RIGHT: bmpAnimation.rotation += 5; return false;

            case KEYCODE_ENTER:  if(canvas.onclick == handleClick){ handleClick(); }return false;
        }
        stage.update();
    }
</script>

</head>
    
<body>
    <div class="description">

    </div>
    <div class="canvasHolder">
        <canvas id="testCanvas" width="400" height="400" style="background-color:#607559">
            Your browser doesn't support canvas. Please download IE9+ on <a href="http://ie.microsoft.com/testdrive">IE Test Drive</a> 
        </canvas>
    </div>
    <button id="Start" onclick=init();>Start</button><button id="Reset" onclick=reset();>Reset</button>
</body>
</html>
